// generated from rosidl_generator_c/resource/msg__struct.h.template

@#######################################################################
@# EmPy template for generating <msg>__struct.h files
@#
@# Context:
@#  - spec (rosidl_parser.MessageSpecification)
@#    Parsed specification of the .msg file
@#  - subfolder (string)
@#    The subfolder / subnamespace of the message
@#    Either 'msg' or 'srv'
@#  - get_header_filename_from_msg_name (function)
@#######################################################################
@
@{
from rosidl_generator_c import msg_type_to_c
from rosidl_generator_c import MSG_TYPE_TO_C

c_namespace = '%s__%s__' % (spec.base_type.pkg_name, subfolder)
c_struct = '%s' % spec.base_type.type
c_full_name = '%s%s' % (c_namespace, c_struct)
}@
@
#ifndef @(spec.base_type.pkg_name.upper())_@(c_full_name.upper())__STRUCT_H_
#define @(spec.base_type.pkg_name.upper())_@(c_full_name.upper())__STRUCT_H_

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#include <rosidl_generator_c/arrays.h>

// include message dependencies
@{
for field in spec.fields:
    pkg_name, type = field.type.pkg_name, field.type.type
    if not field.type.is_primitive_type():
        print('#include <%s/%s-c.h>' % (pkg_name, type))
}@

// types for static array fields
@{
for field in spec.fields:
    if field.type.is_array and field.type.array_size is not None:
        # TODO the generated code fails for non primitive types and needs to be fixed and reenabled
        if field.type.is_primitive_type():
            # pass along the C type
            print('ROSIDL_GENERATE_STATIC_ARRAY(%s, %s, %s, %s);' %
            (c_full_name, field.name, MSG_TYPE_TO_C[field.type.type], field.type.array_size))
        else:
            # complex type: pass the message name as the type
            print('ROSIDL_GENERATE_STATIC_ARRAY(%s, %s, %s, %s);' %
            (c_full_name, field.name, field.type.type, field.type.array_size))
}@

// message struct
typedef struct @(c_full_name)
{
@[for field in spec.fields]@
  @(msg_type_to_c(field.type, field.name, c_full_name));
@[end for]@
} @(c_full_name);

// constants
@[for constant in spec.constants]@
@[if (constant.primitive_type in ['byte', 'int8', 'int16', 'int32', 'int64', 'char'])]@
enum
{
  @(c_full_name + "__" + constant.name) = @(int(constant.value))
};
@[elif (constant.primitive_type in ['uint8', 'uint16', 'uint32', 'uint64'])]@
enum
{
  @(c_full_name + "__" + constant.name) = @(int(constant.value))u
};
@[else]@
static const @(MSG_TYPE_TO_C[constant.primitive_type]) @(c_full_name + "__" + constant.name) = @(constant.value);
@[end if]@
@[end for]@

// symbols for arrays of the message type
ROSIDL_GENERATE_ARRAY(@(c_full_name));

#endif  // @(spec.base_type.pkg_name.upper())_@(c_full_name.upper())__STRUCT_H_
